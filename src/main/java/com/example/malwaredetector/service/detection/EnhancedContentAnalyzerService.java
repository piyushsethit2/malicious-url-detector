package com.example.malwaredetector.service.detection;

import com.example.malwaredetector.model.UrlScanResult;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.time.Duration;
import java.util.*;
import java.util.regex.Pattern;
import java.util.logging.Logger;
import java.util.logging.Level;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;

@Service
public class EnhancedContentAnalyzerService implements BaseDetectionService {
    
    private static final Logger logger = Logger.getLogger(EnhancedContentAnalyzerService.class.getName());
    
    private final HttpClient httpClient;
    private final RestTemplate restTemplate;
    private final DomainWhitelistService whitelistService;
    
    // Enhanced patterns for detecting malicious content
    private static final Pattern SUSPICIOUS_JS_PATTERNS = Pattern.compile(
        "(?i)(eval\\s*\\(|Function\\s*\\(|unescape|fromCharCode|String\\.fromCharCode|document\\.write\\s*\\(|innerHTML\\s*=|setTimeout\\s*\\(|setInterval\\s*\\()"
    );
    
    private static final Pattern PHISHING_FORM_PATTERNS = Pattern.compile(
        "(?i)(<form[^>]*>.*?(password|login|username|email|credit.?card|social.?security|ssn|bank|account|verify|pin|security|authentication)[^>]*>)"
    );
    
    private static final Pattern SUSPICIOUS_IFRAME_PATTERNS = Pattern.compile(
        "(?i)(<iframe[^>]*src=[\"']([^\"']*)[\"'][^>]*>)"
    );
    
    private static final Pattern REDIRECT_PATTERNS = Pattern.compile(
        "(?i)(window\\.location|location\\.href|document\\.location|meta.*?refresh|http-equiv.*?refresh|window\\.open|document\\.domain)"
    );
    
    private static final Pattern OBFUSCATED_CONTENT_PATTERNS = Pattern.compile(
        "(?i)(base64|%[0-9a-fA-F]{2}|&#x[0-9a-fA-F]+|\\\\x[0-9a-fA-F]{2}|\\u[0-9a-fA-F]{4}|\\x[0-9a-fA-F]{2})"
    );
    
    private static final Pattern SUSPICIOUS_KEYWORDS = Pattern.compile(
        "(?i)(malware|virus|trojan|spyware|phishing|scam|fake|hack|crack|warez|keygen|nulled|premium|cheat|bot|exploit|vulnerability|backdoor|rootkit|keylogger|ransomware|adware|spam|download|free|cracked|hack|cheat|bot|exploit|bypass|inject|sql|xss|csrf|ddos|brute|force|overflow|buffer|shell|reverse|bind|meterpreter|payload|dropper|loader|stager|beacon|c2|command|control)"
    );
    
    private static final Pattern SUSPICIOUS_DOMAINS = Pattern.compile(
        "(?i)(bit\\.ly|goo\\.gl|tinyurl|is\\.gd|t\\.co|fb\\.me|ow\\.ly|su\\.pr|twurl|snipurl|short\\.to|BudURL|ping\\.fm|tr\\.im|zip\\.net|sn\\.im|short\\.ie|kl\\.am|wp\\.me|rubyurl|om\\.ly|to\\.ly|bit\\.do|t\\.co|lnkd\\.in|db\\.tt|qr\\.ae|adf\\.ly|goo\\.gl|bitly\\.com|cur\\.lv|tiny\\.cc|ow\\.ly|bit\\.ly|adcrun\\.ch|ity\\.im|q\\.gs|is\\.gd|po\\.st|bc\\.vc|twitthis\\.com|u\\.to|j\\.mp|buzurl\\.com|cutt\\.us|u\\.bb|yourls\\.org|x\\.co|prettylinkpro\\.com|scrnch\\.me|filoops\\.info|vzturl\\.com|qr\\.net|1url\\.com|tweez\\.me|v\\.gd|tr\\.im|link\\.zip\\.net)"
    );
    
    private static final Pattern MALICIOUS_EXTENSIONS = Pattern.compile(
        "(?i)\\.(exe|bat|cmd|com|pif|scr|vbs|js|jar|msi|dmg|app|deb|rpm|apk|ipa|pl|py|sh|ps1|psm1|vbe|wsf|hta|chm|reg|inf|lnk|url|scf|wsh|wsc|msc|gadget|application|appref-ms|appx|appxbundle|msix|msixbundle|msu|msp|mst|ocx|dll|sys|drv|bin|dat|tmp|temp|cache|log|bak|old|swp|swo|lock|pid|sock|fifo|pipe|socket|device|proc|sys|dev|etc|var|usr|home|root|boot|mnt|media|opt|srv|sbin|lib|lib64|bin|sbin|usr|local|share|doc|man|info|include|src|build|dist|target|out|bin|obj|debug|release|build|dist|target|out|bin|obj|debug|release)$"
    );
    
    private static final Pattern SUSPICIOUS_IP_PATTERNS = Pattern.compile(
        "(?i)(10\\.|172\\.(1[6-9]|2[0-9]|3[01])\\.|192\\.168\\.|127\\.|0\\.|169\\.254\\.|224\\.|240\\.)"
    );
    
    @Autowired
    public EnhancedContentAnalyzerService(DomainWhitelistService whitelistService) {
        this.whitelistService = whitelistService;
        this.httpClient = HttpClient.newBuilder()
                .connectTimeout(Duration.ofSeconds(10))
                .followRedirects(HttpClient.Redirect.NORMAL)
                .build();
        this.restTemplate = new RestTemplate();
    }
    
    @Override
    public UrlScanResult.DetectionResult detect(String url) {
        try {
            // Check if domain is whitelisted first
            if (whitelistService.isWhitelisted(url)) {
                return new UrlScanResult.DetectionResult(
                    getMethodName(), false, "Domain is whitelisted as legitimate", 0.0
                );
            }
            
            List<String> issues = new ArrayList<>();
            double confidence = 0.0;
            
            // Multi-strategy content analysis
            ContentAnalysisResult contentResult = analyzeContentMultiStrategy(url);
            
            // Analyze URL structure and domain
            confidence += analyzeUrlStructure(url, issues);
            confidence += analyzeDomainReputation(url, issues);
            confidence += analyzeNetworkIndicators(url, issues);
            
            // Analyze content if available
            if (contentResult != null && contentResult.content != null) {
                confidence += analyzeSuspiciousJavaScript(contentResult.content, issues);
                confidence += analyzePhishingForms(contentResult.content, issues);
                confidence += analyzeSuspiciousIframes(contentResult.content, issues);
                confidence += analyzeRedirects(contentResult.content, issues);
                confidence += analyzeObfuscatedContent(contentResult.content, issues);
                confidence += analyzeSuspiciousKeywords(contentResult.content, issues);
                confidence += analyzeExternalResources(contentResult.content, issues);
                confidence += analyzeSuspiciousLinks(contentResult.content, issues);
                confidence += analyzeMetaTags(contentResult.content, issues);
                confidence += analyzeScriptSources(contentResult.content, issues);
            }
            
            // Add content accessibility issues
            if (contentResult != null && !contentResult.accessible) {
                issues.add("Site inaccessible - potential indicator of malicious domain");
                confidence += 0.1;
            }
            
            // Adjust threshold based on whitelist status
            double threshold = whitelistService.isWhitelisted(url) ? 0.6 : 0.4;
            boolean isMalicious = confidence > threshold;
            confidence = Math.min(confidence, 1.0);
            
            String details = issues.isEmpty() ? 
                "No malicious content detected" : 
                "Content issues: " + String.join(", ", issues);
            
            return new UrlScanResult.DetectionResult(
                getMethodName(), isMalicious, details, confidence
            );
            
        } catch (Exception e) {
            logger.log(Level.WARNING, "Error analyzing content for URL: " + url, e);
            return new UrlScanResult.DetectionResult(
                getMethodName(), false, "Error: " + e.getMessage(), 0.0
            );
        }
    }
    
    private static class ContentAnalysisResult {
        String content;
        boolean accessible;
        String error;
        
        ContentAnalysisResult(String content, boolean accessible, String error) {
            this.content = content;
            this.accessible = accessible;
            this.error = error;
        }
    }
    
    private ContentAnalysisResult analyzeContentMultiStrategy(String url) {
        // Strategy 1: Direct HTTP request
        ContentAnalysisResult result = fetchContentDirect(url);
        if (result.accessible && result.content != null) {
            return result;
        }
        
        // Strategy 2: Try with different User-Agent
        result = fetchContentWithCustomUserAgent(url);
        if (result.accessible && result.content != null) {
            return result;
        }
        
        // Strategy 3: Try HTTP if HTTPS failed
        if (url.startsWith("https://")) {
            String httpUrl = url.replace("https://", "http://");
            result = fetchContentDirect(httpUrl);
            if (result.accessible && result.content != null) {
                return result;
            }
        }
        
        // Strategy 4: Try without www prefix
        if (url.contains("www.")) {
            String noWwwUrl = url.replace("www.", "");
            result = fetchContentDirect(noWwwUrl);
            if (result.accessible && result.content != null) {
                return result;
            }
        }
        
        // Strategy 5: Try with www prefix
        if (!url.contains("www.") && url.contains("://")) {
            String withWwwUrl = url.replace("://", "://www.");
            result = fetchContentDirect(withWwwUrl);
            if (result.accessible && result.content != null) {
                return result;
            }
        }
        
        // All strategies failed
        return new ContentAnalysisResult(null, false, "All content fetch strategies failed");
    }
    
    private ContentAnalysisResult fetchContentDirect(String url) {
        try {
            String urlWithScheme = ensureUrlScheme(url);
            URI uri = URI.create(urlWithScheme);
            
            HttpRequest request = HttpRequest.newBuilder()
                .uri(uri)
                .header("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
                .header("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
                .header("Accept-Language", "en-US,en;q=0.5")
                .timeout(Duration.ofSeconds(10))
                .build();
            
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            if (response.statusCode() >= 200 && response.statusCode() < 300) {
                return new ContentAnalysisResult(response.body(), true, null);
            } else {
                return new ContentAnalysisResult(null, false, "HTTP " + response.statusCode());
            }
        } catch (Exception e) {
            return new ContentAnalysisResult(null, false, e.getMessage());
        }
    }
    
    private ContentAnalysisResult fetchContentWithCustomUserAgent(String url) {
        try {
            String urlWithScheme = ensureUrlScheme(url);
            URI uri = URI.create(urlWithScheme);
            
            HttpRequest request = HttpRequest.newBuilder()
                .uri(uri)
                .header("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36")
                .header("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8")
                .header("Accept-Language", "en-US,en;q=0.9")
                .header("Accept-Encoding", "gzip, deflate, br")
                .header("DNT", "1")
                .header("Connection", "keep-alive")
                .header("Upgrade-Insecure-Requests", "1")
                .timeout(Duration.ofSeconds(10))
                .build();
            
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            if (response.statusCode() >= 200 && response.statusCode() < 300) {
                return new ContentAnalysisResult(response.body(), true, null);
            } else {
                return new ContentAnalysisResult(null, false, "HTTP " + response.statusCode());
            }
        } catch (Exception e) {
            return new ContentAnalysisResult(null, false, e.getMessage());
        }
    }
    
    private String ensureUrlScheme(String url) {
        if (!url.startsWith("http://") && !url.startsWith("https://")) {
            return "https://" + url;
        }
        return url;
    }
    
    private double analyzeUrlStructure(String url, List<String> issues) {
        double confidence = 0.0;
        
        // Check for suspicious URL shortening services
        if (SUSPICIOUS_DOMAINS.matcher(url).find()) {
            issues.add("URL shortening service detected");
            confidence += 0.2;
        }
        
        // Check for malicious file extensions
        if (MALICIOUS_EXTENSIONS.matcher(url).find()) {
            issues.add("Suspicious file extension detected");
            confidence += 0.4;
        }
        
        // Check for suspicious IP patterns
        if (SUSPICIOUS_IP_PATTERNS.matcher(url).find()) {
            issues.add("Suspicious IP address pattern detected");
            confidence += 0.3;
        }
        
        // Check for excessive subdomains
        String domain = extractDomain(url);
        if (domain != null && domain.split("\\.").length > 4) {
            issues.add("Excessive subdomains detected");
            confidence += 0.2;
        }
        
        // Check for suspicious characters
        if (url.contains("%") || url.contains("&#") || url.contains("\\x")) {
            issues.add("URL encoding/obfuscation detected");
            confidence += 0.3;
        }
        
        return confidence;
    }
    
    private double analyzeDomainReputation(String url, List<String> issues) {
        double confidence = 0.0;
        String domain = extractDomain(url);
        
        if (domain == null) {
            return 0.0;
        }
        
        // Check domain age (new domains are more suspicious)
        try {
            // This would require integration with WHOIS API
            // For now, we'll use basic heuristics
            if (domain.length() > 50) {
                issues.add("Unusually long domain name");
                confidence += 0.2;
            }
            
            // Check for random-looking domains
            if (isRandomLookingDomain(domain)) {
                issues.add("Random-looking domain name");
                confidence += 0.3;
            }
            
        } catch (Exception e) {
            logger.log(Level.FINE, "Error analyzing domain reputation: " + e.getMessage());
        }
        
        return confidence;
    }
    
    private double analyzeNetworkIndicators(String url, List<String> issues) {
        double confidence = 0.0;
        String domain = extractDomain(url);
        
        if (domain == null) {
            return 0.0;
        }
        
        try {
            // Check if domain resolves
            InetAddress address = InetAddress.getByName(domain);
            
            // Check for private IP addresses
            if (address.isSiteLocalAddress() || address.isLoopbackAddress()) {
                issues.add("Private/local IP address detected");
                confidence += 0.4;
            }
            
            // Check for suspicious IP ranges
            String ip = address.getHostAddress();
            if (ip.startsWith("10.") || ip.startsWith("172.") || ip.startsWith("192.168.")) {
                issues.add("Private network IP detected");
                confidence += 0.3;
            }
            
        } catch (UnknownHostException e) {
            issues.add("Domain does not resolve - potential indicator of malicious site");
            confidence += 0.2;
        } catch (Exception e) {
            logger.log(Level.FINE, "Error analyzing network indicators: " + e.getMessage());
        }
        
        return confidence;
    }
    
    private String extractDomain(String url) {
        try {
            String urlWithScheme = ensureUrlScheme(url);
            URI uri = URI.create(urlWithScheme);
            return uri.getHost();
        } catch (Exception e) {
            return null;
        }
    }
    
    private boolean isRandomLookingDomain(String domain) {
        // Check for excessive numbers or random characters
        int numbers = domain.replaceAll("[^0-9]", "").length();
        int letters = domain.replaceAll("[^a-zA-Z]", "").length();
        
        // If more than 30% are numbers, it's suspicious
        if (letters > 0 && (double) numbers / (numbers + letters) > 0.3) {
            return true;
        }
        
        // Check for random character patterns
        if (domain.matches(".*[a-z]{10,}.*") || domain.matches(".*[0-9]{8,}.*")) {
            return true;
        }
        
        return false;
    }
    
    private double analyzeSuspiciousJavaScript(String content, List<String> issues) {
        if (SUSPICIOUS_JS_PATTERNS.matcher(content).find()) {
            issues.add("Suspicious JavaScript detected");
            return 0.3;
        }
        return 0.0;
    }
    
    private double analyzePhishingForms(String content, List<String> issues) {
        if (PHISHING_FORM_PATTERNS.matcher(content).find()) {
            issues.add("Potential phishing form detected");
            return 0.4;
        }
        return 0.0;
    }
    
    private double analyzeSuspiciousIframes(String content, List<String> issues) {
        if (SUSPICIOUS_IFRAME_PATTERNS.matcher(content).find()) {
            issues.add("Suspicious iframe detected");
            return 0.3;
        }
        return 0.0;
    }
    
    private double analyzeRedirects(String content, List<String> issues) {
        if (REDIRECT_PATTERNS.matcher(content).find()) {
            issues.add("Suspicious redirects detected");
            return 0.25;
        }
        return 0.0;
    }
    
    private double analyzeObfuscatedContent(String content, List<String> issues) {
        if (OBFUSCATED_CONTENT_PATTERNS.matcher(content).find()) {
            issues.add("Obfuscated content detected");
            return 0.35;
        }
        return 0.0;
    }
    
    private double analyzeSuspiciousKeywords(String content, List<String> issues) {
        if (SUSPICIOUS_KEYWORDS.matcher(content).find()) {
            issues.add("Suspicious keywords in content");
            return 0.2;
        }
        return 0.0;
    }
    
    private double analyzeExternalResources(String content, List<String> issues) {
        // Check for external resources from suspicious domains
        String[] suspiciousDomains = {
            "malware.com", "virus.com", "phishing.com", "scam.com", "fake.com",
            "hack.com", "crack.com", "warez.com", "keygen.com", "nulled.com"
        };
        
        for (String domain : suspiciousDomains) {
            if (content.toLowerCase().contains(domain)) {
                issues.add("External resource from suspicious domain: " + domain);
                return 0.3;
            }
        }
        
        return 0.0;
    }
    
    private double analyzeSuspiciousLinks(String content, List<String> issues) {
        // Check for suspicious links in content
        Pattern linkPattern = Pattern.compile("href=[\"']([^\"']*)[\"']");
        java.util.regex.Matcher matcher = linkPattern.matcher(content);
        
        while (matcher.find()) {
            String link = matcher.group(1);
            if (SUSPICIOUS_DOMAINS.matcher(link).find()) {
                issues.add("Suspicious link detected: " + link);
                return 0.25;
            }
        }
        
        return 0.0;
    }
    
    private double analyzeMetaTags(String content, List<String> issues) {
        // Check for suspicious meta tags
        Pattern metaPattern = Pattern.compile("<meta[^>]*>");
        java.util.regex.Matcher matcher = metaPattern.matcher(content);
        
        while (matcher.find()) {
            String meta = matcher.group(0).toLowerCase();
            if (meta.contains("refresh") && meta.contains("url=")) {
                issues.add("Meta refresh redirect detected");
                return 0.3;
            }
        }
        
        return 0.0;
    }
    
    private double analyzeScriptSources(String content, List<String> issues) {
        // Check for suspicious script sources
        Pattern scriptPattern = Pattern.compile("<script[^>]*src=[\"']([^\"']*)[\"'][^>]*>");
        java.util.regex.Matcher matcher = scriptPattern.matcher(content);
        
        while (matcher.find()) {
            String src = matcher.group(1);
            if (SUSPICIOUS_DOMAINS.matcher(src).find()) {
                issues.add("Suspicious script source: " + src);
                return 0.3;
            }
        }
        
        return 0.0;
    }
    
    @Override
    public String getMethodName() {
        return "Enhanced Content Analysis";
    }
    
    @Override
    public double getConfidence() {
        return 0.8;
    }
} 