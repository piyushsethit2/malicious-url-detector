package com.example.malwaredetector.service.detection;

import com.example.malwaredetector.model.UrlScanResult;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
import java.util.logging.Logger;
import java.util.logging.Level;

@Service
public class DynamicContentAnalyzerService implements BaseDetectionService {
    
    private static final Logger logger = Logger.getLogger(DynamicContentAnalyzerService.class.getName());
    
    private final HttpClient httpClient;
    private final DomainWhitelistService whitelistService;
    
    // Patterns for detecting malicious content
    private static final Pattern SUSPICIOUS_JS_PATTERNS = Pattern.compile(
        "(?i)(eval\\s*\\(|Function\\s*\\(|unescape|fromCharCode|String\\.fromCharCode|document\\.write\\s*\\(|innerHTML\\s*=|setTimeout\\s*\\(|setInterval\\s*\\()"
    );
    
    private static final Pattern PHISHING_FORM_PATTERNS = Pattern.compile(
        "(?i)(<form[^>]*>.*?(password|login|username|email|credit.?card|social.?security|ssn|bank|account|verify)[^>]*>)"
    );
    
    private static final Pattern SUSPICIOUS_IFRAME_PATTERNS = Pattern.compile(
        "(?i)(<iframe[^>]*src=[\"']([^\"']*)[\"'][^>]*>)"
    );
    
    private static final Pattern REDIRECT_PATTERNS = Pattern.compile(
        "(?i)(window\\.location|location\\.href|document\\.location|meta.*?refresh|http-equiv.*?refresh)"
    );
    
    private static final Pattern OBFUSCATED_CONTENT_PATTERNS = Pattern.compile(
        "(?i)(base64|%[0-9a-fA-F]{2}|&#x[0-9a-fA-F]+)"
    );
    
    private static final Pattern SUSPICIOUS_KEYWORDS = Pattern.compile(
        "(?i)(malware|virus|trojan|spyware|phishing|scam|fake|hack|crack|warez|keygen|nulled|premium|cheat|bot|exploit|vulnerability|backdoor|rootkit|keylogger|ransomware|adware|spam|download|free|cracked|hack|cheat|bot|exploit)"
    );
    
    @Autowired
    public DynamicContentAnalyzerService(DomainWhitelistService whitelistService) {
        this.whitelistService = whitelistService;
        this.httpClient = HttpClient.newBuilder()
                .connectTimeout(Duration.ofSeconds(15))
                .followRedirects(HttpClient.Redirect.NORMAL)
                .build();
    }
    
    @Override
    public UrlScanResult.DetectionResult detect(String url) {
        try {
            // Check if domain is whitelisted first
            if (whitelistService.isWhitelisted(url)) {
                return new UrlScanResult.DetectionResult(
                    getMethodName(), false, "Domain is whitelisted as legitimate", 0.0
                );
            }
            
            List<String> issues = new ArrayList<>();
            double confidence = 0.0;
            
            // Fetch the webpage content
            String content = fetchWebpageContent(url);
            if (content == null) {
                return new UrlScanResult.DetectionResult(
                    getMethodName(), false, "Could not fetch webpage content", 0.0
                );
            }
            
            // Analyze content for malicious patterns
            confidence += analyzeSuspiciousJavaScript(content, issues);
            confidence += analyzePhishingForms(content, issues);
            confidence += analyzeSuspiciousIframes(content, issues);
            confidence += analyzeRedirects(content, issues);
            confidence += analyzeObfuscatedContent(content, issues);
            confidence += analyzeSuspiciousKeywords(content, issues);
            confidence += analyzeExternalResources(content, issues);
            confidence += analyzeSuspiciousLinks(content, issues);
            
            // Adjust threshold based on whitelist status
            double threshold = whitelistService.isWhitelisted(url) ? 0.6 : 0.4;
            boolean isMalicious = confidence > threshold;
            confidence = Math.min(confidence, 1.0);
            
            String details = issues.isEmpty() ? 
                "No malicious content detected" : 
                "Content issues: " + String.join(", ", issues);
            
            return new UrlScanResult.DetectionResult(
                getMethodName(), isMalicious, details, confidence
            );
            
        } catch (Exception e) {
            logger.log(Level.WARNING, "Error analyzing content for URL: " + url, e);
            return new UrlScanResult.DetectionResult(
                getMethodName(), false, "Error: " + e.getMessage(), 0.0
            );
        }
    }
    
    private String fetchWebpageContent(String url) {
        try {
            // Ensure URL has a scheme
            String urlWithScheme = url;
            if (!url.startsWith("http://") && !url.startsWith("https://")) {
                urlWithScheme = "https://" + url;  // Prefer HTTPS
            }
            
            // Validate URI
            URI uri = URI.create(urlWithScheme);
            if (uri.getScheme() == null || uri.getHost() == null) {
                logger.warning("Invalid URL format: " + url);
                return null;
            }
            
            HttpRequest request = HttpRequest.newBuilder()
                .uri(uri)
                .header("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")
                .header("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8")
                .header("Accept-Language", "en-US,en;q=0.5")
                .header("Accept-Encoding", "gzip, deflate")
                .header("Upgrade-Insecure-Requests", "1")
                .timeout(Duration.ofSeconds(15))
                .build();
            
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            if (response.statusCode() >= 200 && response.statusCode() < 300) {
                return response.body();
            } else {
                logger.warning("Failed to fetch content from " + url + ", status: " + response.statusCode());
                return null;
            }
        } catch (Exception e) {
            logger.log(Level.WARNING, "Error fetching content from " + url, e);
            return null;
        }
    }
    
    private double analyzeSuspiciousJavaScript(String content, List<String> issues) {
        if (SUSPICIOUS_JS_PATTERNS.matcher(content).find()) {
            issues.add("Suspicious JavaScript detected");
            return 0.3;
        }
        return 0.0;
    }
    
    private double analyzePhishingForms(String content, List<String> issues) {
        if (PHISHING_FORM_PATTERNS.matcher(content).find()) {
            issues.add("Potential phishing form detected");
            return 0.4;
        }
        return 0.0;
    }
    
    private double analyzeSuspiciousIframes(String content, List<String> issues) {
        if (SUSPICIOUS_IFRAME_PATTERNS.matcher(content).find()) {
            issues.add("Suspicious iframe detected");
            return 0.3;
        }
        return 0.0;
    }
    
    private double analyzeRedirects(String content, List<String> issues) {
        if (REDIRECT_PATTERNS.matcher(content).find()) {
            issues.add("Suspicious redirects detected");
            return 0.25;
        }
        return 0.0;
    }
    
    private double analyzeObfuscatedContent(String content, List<String> issues) {
        if (OBFUSCATED_CONTENT_PATTERNS.matcher(content).find()) {
            issues.add("Obfuscated content detected");
            return 0.35;
        }
        return 0.0;
    }
    
    private double analyzeSuspiciousKeywords(String content, List<String> issues) {
        if (SUSPICIOUS_KEYWORDS.matcher(content).find()) {
            issues.add("Suspicious keywords in content");
            return 0.2;
        }
        return 0.0;
    }
    
    private double analyzeExternalResources(String content, List<String> issues) {
        // Check for external resources from suspicious domains
        String[] suspiciousDomains = {
            "malware.com", "virus.com", "hack.com", "crack.com", "warez.com", 
            "nulled.com", "premium.com", "keygen.com", "cracked.com"
        };
        
        for (String domain : suspiciousDomains) {
            if (content.toLowerCase().contains(domain)) {
                issues.add("External resources from suspicious domain: " + domain);
                return 0.3;
            }
        }
        return 0.0;
    }
    
    private double analyzeSuspiciousLinks(String content, List<String> issues) {
        // Check for suspicious link patterns
        Pattern suspiciousLinkPattern = Pattern.compile(
            "(?i)(https?://[^\\s\"']*(malware|virus|trojan|spyware|phishing|scam|fake|hack|crack|warez|keygen|nulled|premium|cheat|bot|exploit)[^\\s\"']*)"
        );
        
        if (suspiciousLinkPattern.matcher(content).find()) {
            issues.add("Suspicious links detected in content");
            return 0.25;
        }
        return 0.0;
    }
    
    @Override
    public String getMethodName() {
        return "Dynamic Content Analysis";
    }
    
    @Override
    public double getConfidence() {
        return 0.9;
    }
} 