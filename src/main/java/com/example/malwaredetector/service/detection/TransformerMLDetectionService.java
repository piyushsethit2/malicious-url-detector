package com.example.malwaredetector.service.detection;

import com.example.malwaredetector.model.UrlScanResult;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Value;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.net.URI;
import java.time.Duration;
import java.util.logging.Logger;
import java.util.logging.Level;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;

import org.json.JSONObject;
import org.json.JSONException;

@Service
public class TransformerMLDetectionService implements BaseDetectionService {

    private static final Logger logger = Logger.getLogger(TransformerMLDetectionService.class.getName());

    @Value("${ML_MICROSERVICE_URL:${ml.microservice.url:http://localhost:5002}}")
    private String mlServiceUrl;

    @Value("${ml.microservice.timeout:10}")
    private int timeoutSeconds;

    @Value("${ml.microservice.enabled:true}")
    private boolean enabled;

    private final HttpClient httpClient = HttpClient.newBuilder()
            .connectTimeout(Duration.ofSeconds(5))
            .build();

    @Override
    public UrlScanResult.DetectionResult detect(String url) {
        return detect(url, null);
    }

    public UrlScanResult.DetectionResult detect(String url, String content) {
        if (!enabled) {
            return new UrlScanResult.DetectionResult(
                getMethodName(), false, "ML microservice is disabled", 0.0
            );
        }

        try {
            // Prepare request body
            JSONObject requestBody = new JSONObject();
            requestBody.put("url", url);
            if (content != null && !content.trim().isEmpty()) {
                requestBody.put("content", content);
            }

            // Create HTTP request
            HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create(mlServiceUrl + "/predict"))
                    .timeout(Duration.ofSeconds(timeoutSeconds))
                    .header("Content-Type", "application/json")
                    .header("Accept", "application/json")
                    .POST(HttpRequest.BodyPublishers.ofString(requestBody.toString()))
                    .build();

            // Send request asynchronously with timeout
            CompletableFuture<HttpResponse<String>> future = httpClient.sendAsync(request, 
                    HttpResponse.BodyHandlers.ofString());

            HttpResponse<String> response = future.get(timeoutSeconds, TimeUnit.SECONDS);

            if (response.statusCode() == 200) {
                JSONObject resp = new JSONObject(response.body());
                
                String label = resp.optString("label", "unknown");
                double confidence = resp.optDouble("confidence", 0.0);
                String model = resp.optString("model", "unknown");
                String device = resp.optString("device", "unknown");

                String details = String.format("ML Model: %s (%s), Label: %s, Confidence: %.3f, Probability: %.3f", 
                        model, device, label, confidence, confidence);
                
                // Consider malicious if label is "malicious" and confidence is above threshold
                boolean isMalicious = "malicious".equalsIgnoreCase(label) && confidence > 0.4;

                logger.info(String.format("ML prediction for %s: %s (confidence: %.3f, isMalicious: %s)", 
                    url, label, confidence, isMalicious));

                return new UrlScanResult.DetectionResult(
                    getMethodName(), isMalicious, details, confidence
                );

            } else {
                logger.warning(String.format("ML service returned HTTP %d for URL: %s", response.statusCode(), url));
                return new UrlScanResult.DetectionResult(
                    getMethodName(), false, "ML service error: HTTP " + response.statusCode(), 0.0
                );
            }

        } catch (Exception e) {
            logger.log(Level.WARNING, "Error calling ML microservice for URL: " + url, e);
            return new UrlScanResult.DetectionResult(
                getMethodName(), false, "ML service exception: " + e.getMessage(), 0.0
            );
        }
    }

    @Override
    public String getMethodName() {
        return "TransformerML";
    }

    @Override
    public double getConfidence() {
        return 0.8; // Default confidence for ML service
    }

    /**
     * Check if the ML microservice is healthy
     */
    public boolean isHealthy() {
        try {
            HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create(mlServiceUrl + "/health"))
                    .timeout(Duration.ofSeconds(5))
                    .GET()
                    .build();

            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            return response.statusCode() == 200;
        } catch (Exception e) {
            logger.warning("ML microservice health check failed: " + e.getMessage());
            return false;
        }
    }

    /**
     * Get information about the ML model
     */
    public JSONObject getModelInfo() {
        try {
            HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create(mlServiceUrl + "/info"))
                    .timeout(Duration.ofSeconds(5))
                    .GET()
                    .build();

            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            if (response.statusCode() == 200) {
                return new JSONObject(response.body());
            }
        } catch (Exception e) {
            logger.warning("Failed to get model info: " + e.getMessage());
        }
        return new JSONObject();
    }
} 