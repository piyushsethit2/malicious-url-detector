package com.example.malwaredetector.service.detection;

import com.example.malwaredetector.model.UrlScanResult.DetectionResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.Map;

/**
 * External ML Detection Service for Render deployment
 * Uses HuggingFace Inference API instead of local microservices
 */
@Service
public class ExternalMlDetectionService implements BaseDetectionService {
    
    private static final Logger log = LoggerFactory.getLogger(ExternalMlDetectionService.class);
    
    private final RestTemplate restTemplate;
    private final String mlApiUrl;
    private final boolean mlApiEnabled;
    private final String apiKey;
    
    public ExternalMlDetectionService(RestTemplate restTemplate, 
                                    @Value("${ml.api.huggingface.api-url:https://api-inference.huggingface.co/models}") String apiUrl,
                                    @Value("${ml.api.huggingface.model-name:microsoft/DialoGPT-medium}") String modelName,
                                    @Value("${ml.api.enabled:true}") boolean enabled,
                                    @Value("${ml.api.huggingface.api-key:}") String apiKey) {
        this.restTemplate = restTemplate;
        this.mlApiUrl = apiUrl + "/" + modelName;
        this.mlApiEnabled = enabled;
        this.apiKey = apiKey;
    }
    
    @Override
    public DetectionResult detect(String url) {
        if (!mlApiEnabled) {
            log.info("ML API is disabled, skipping external ML detection for URL: {}", url);
            return new DetectionResult("EXTERNAL_ML", false, "ML API is disabled", 0.0);
        }
        
        try {
            log.info("Performing external ML detection for URL: {}", url);
            
            // Use HuggingFace Inference API
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);
            
            // Add API key if available
            if (apiKey != null && !apiKey.trim().isEmpty()) {
                headers.setBearerAuth(apiKey);
            }
            
            Map<String, Object> requestBody = Map.of(
                "inputs", url,
                "options", Map.of("wait_for_model", true)
            );
            
            HttpEntity<Map<String, Object>> request = new HttpEntity<>(requestBody, headers);
            
            ResponseEntity<Map> response = restTemplate.postForEntity(
                mlApiUrl, request, Map.class);
            
            // Process response and return result
            if (response.getStatusCode() == HttpStatus.OK) {
                log.info("External ML API detection successful for URL: {}", url);
                return new DetectionResult(
                    "EXTERNAL_ML", 
                    false, 
                    "External ML API detection completed successfully",
                    0.8
                );
            } else {
                log.warn("External ML API returned non-OK status: {} for URL: {}", 
                    response.getStatusCode(), url);
                return new DetectionResult(
                    "EXTERNAL_ML", 
                    true, 
                    "External ML API returned status: " + response.getStatusCode(),
                    0.6
                );
            }
            
        } catch (Exception e) {
            log.warn("External ML API detection failed for URL: {}", url, e);
            
            // Fallback to basic URL analysis when API fails
            return performFallbackAnalysis(url);
        }
    }
    
    private DetectionResult performFallbackAnalysis(String url) {
        // Simple fallback analysis when external API is not available
        try {
            String lowerUrl = url.toLowerCase();
            
            // Check for common malicious patterns
            boolean hasSuspiciousPatterns = 
                lowerUrl.contains("login") || 
                lowerUrl.contains("signin") || 
                lowerUrl.contains("reset") || 
                lowerUrl.contains("password") ||
                lowerUrl.contains("account") ||
                lowerUrl.contains("verify") ||
                lowerUrl.contains("confirm");
            
            // Check for suspicious domains
            boolean hasSuspiciousDomain = 
                lowerUrl.contains("bit.ly") ||
                lowerUrl.contains("tinyurl") ||
                lowerUrl.contains("goo.gl") ||
                lowerUrl.contains("t.co");
            
            double confidence = 0.0;
            String details = "Fallback analysis completed";
            
            if (hasSuspiciousPatterns && hasSuspiciousDomain) {
                confidence = 0.7;
                details = "Suspicious patterns detected in URL";
            } else if (hasSuspiciousPatterns || hasSuspiciousDomain) {
                confidence = 0.4;
                details = "Some suspicious indicators detected";
            } else {
                confidence = 0.2;
                details = "No obvious suspicious patterns detected";
            }
            
            return new DetectionResult(
                "EXTERNAL_ML", 
                confidence > 0.5, 
                details,
                confidence
            );
            
        } catch (Exception e) {
            return new DetectionResult(
                "EXTERNAL_ML", 
                false, 
                "Fallback analysis failed: " + e.getMessage(),
                0.0
            );
        }
    }
    
    @Override
    public String getMethodName() {
        return "EXTERNAL_ML";
    }
    
    @Override
    public double getConfidence() {
        return 0.8;
    }
} 