package com.example.malwaredetector.service.detection;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.logging.Logger;
import java.util.logging.Level;
import java.time.LocalDateTime;
import java.util.Map;

@Service
public class DynamicWhitelistManager {
    
    private static final Logger logger = Logger.getLogger(DynamicWhitelistManager.class.getName());
    
    private final DomainWhitelistService whitelistService;
    private final Map<String, DomainReputation> domainReputations = new ConcurrentHashMap<>();
    private final Map<String, Integer> falsePositiveCounts = new ConcurrentHashMap<>();
    private final Map<String, Integer> truePositiveCounts = new ConcurrentHashMap<>();
    
    @Autowired
    public DynamicWhitelistManager(DomainWhitelistService whitelistService) {
        this.whitelistService = whitelistService;
    }
    
    public void recordScanResult(String url, boolean wasDetectedAsMalicious, boolean wasActuallyMalicious) {
        try {
            String domain = extractDomain(url);
            if (domain == null) return;
            
            DomainReputation reputation = domainReputations.computeIfAbsent(domain, k -> new DomainReputation());
            
            if (wasDetectedAsMalicious && !wasActuallyMalicious) {
                // False positive
                reputation.falsePositiveCount++;
                falsePositiveCounts.merge(domain, 1, Integer::sum);
                logger.info("False positive recorded for domain: " + domain);
                
                // Auto-add to whitelist if enough false positives
                if (reputation.falsePositiveCount >= 3) {
                    autoAddToWhitelist(domain);
                }
            } else if (!wasDetectedAsMalicious && wasActuallyMalicious) {
                // False negative
                reputation.falseNegativeCount++;
                truePositiveCounts.merge(domain, 1, Integer::sum);
                logger.info("False negative recorded for domain: " + domain);
                
                // Remove from whitelist if it was there
                if (whitelistService.isWhitelisted(url)) {
                    autoRemoveFromWhitelist(domain);
                }
            } else if (wasDetectedAsMalicious && wasActuallyMalicious) {
                // True positive
                reputation.truePositiveCount++;
                truePositiveCounts.merge(domain, 1, Integer::sum);
            } else {
                // True negative
                reputation.trueNegativeCount++;
            }
            
            reputation.lastUpdated = LocalDateTime.now();
            
        } catch (Exception e) {
            logger.log(Level.WARNING, "Error recording scan result for URL: " + url, e);
        }
    }
    
    public void autoAddToWhitelist(String domain) {
        try {
            if (!whitelistService.isWhitelisted("https://" + domain)) {
                whitelistService.addToWhitelist(domain);
                logger.info("Automatically added domain to whitelist: " + domain);
            }
        } catch (Exception e) {
            logger.log(Level.WARNING, "Error auto-adding domain to whitelist: " + domain, e);
        }
    }
    
    public void autoRemoveFromWhitelist(String domain) {
        try {
            whitelistService.removeFromWhitelist(domain);
            logger.info("Automatically removed domain from whitelist: " + domain);
        } catch (Exception e) {
            logger.log(Level.WARNING, "Error auto-removing domain from whitelist: " + domain, e);
        }
    }
    
    public void manualAddToWhitelist(String domain) {
        try {
            whitelistService.addToWhitelist(domain);
            logger.info("Manually added domain to whitelist: " + domain);
        } catch (Exception e) {
            logger.log(Level.WARNING, "Error manually adding domain to whitelist: " + domain, e);
        }
    }
    
    public void manualRemoveFromWhitelist(String domain) {
        try {
            whitelistService.removeFromWhitelist(domain);
            logger.info("Manually removed domain from whitelist: " + domain);
        } catch (Exception e) {
            logger.log(Level.WARNING, "Error manually removing domain from whitelist: " + domain, e);
        }
    }
    
    public DomainReputation getDomainReputation(String domain) {
        return domainReputations.get(domain);
    }
    
    public Map<String, DomainReputation> getAllDomainReputations() {
        return new ConcurrentHashMap<>(domainReputations);
    }
    
    public Set<String> getWhitelistedDomains() {
        return whitelistService.getWhitelistedDomains();
    }
    
    public boolean isWhitelisted(String url) {
        return whitelistService.isWhitelisted(url);
    }
    
    private String extractDomain(String url) {
        try {
            java.net.URI uri = new java.net.URI(url);
            String host = uri.getHost();
            return host != null ? host.toLowerCase() : null;
        } catch (Exception e) {
            // Fallback to regex extraction
            java.util.regex.Pattern domainPattern = java.util.regex.Pattern.compile("https?://([^/]+)");
            java.util.regex.Matcher matcher = domainPattern.matcher(url);
            if (matcher.find()) {
                return matcher.group(1).toLowerCase();
            }
            return null;
        }
    }
    
    public static class DomainReputation {
        public int truePositiveCount = 0;
        public int trueNegativeCount = 0;
        public int falsePositiveCount = 0;
        public int falseNegativeCount = 0;
        public LocalDateTime lastUpdated = LocalDateTime.now();
        
        public double getAccuracy() {
            int total = truePositiveCount + trueNegativeCount + falsePositiveCount + falseNegativeCount;
            if (total == 0) return 0.0;
            return (double) (truePositiveCount + trueNegativeCount) / total;
        }
        
        public double getFalsePositiveRate() {
            int total = trueNegativeCount + falsePositiveCount;
            if (total == 0) return 0.0;
            return (double) falsePositiveCount / total;
        }
        
        public double getFalseNegativeRate() {
            int total = truePositiveCount + falseNegativeCount;
            if (total == 0) return 0.0;
            return (double) falseNegativeCount / total;
        }
    }
} 