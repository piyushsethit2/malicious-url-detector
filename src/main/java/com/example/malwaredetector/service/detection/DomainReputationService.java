package com.example.malwaredetector.service.detection;

import com.example.malwaredetector.model.UrlScanResult;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

@Service
public class DomainReputationService implements BaseDetectionService {

    private final HttpClient httpClient;
    private final DomainWhitelistService whitelistService;
    private static final Pattern DOMAIN_PATTERN = Pattern.compile("https?://([^/]+)");

    @Autowired
    public DomainReputationService(DomainWhitelistService whitelistService) {
        this.whitelistService = whitelistService;
        this.httpClient = HttpClient.newBuilder()
                .connectTimeout(Duration.ofSeconds(5))
                .build();
    }

    @Override
    public UrlScanResult.DetectionResult detect(String url) {
        try {
            String domain = extractDomain(url);
            if (domain == null) {
                return new UrlScanResult.DetectionResult(
                    getMethodName(), false, "Could not extract domain", 0.0
                );
            }

            // Check if domain is whitelisted - if so, return clean result
            if (whitelistService.isWhitelisted(url)) {
                return new UrlScanResult.DetectionResult(
                    getMethodName(), false, "Domain is whitelisted as legitimate", 0.0
                );
            }

            List<String> issues = new ArrayList<>();
            double confidence = 0.0;

            // Check for suspicious TLDs
            if (isSuspiciousTLD(domain)) {
                issues.add("Suspicious TLD detected");
                confidence += 0.3;
            }

            // Check domain length
            if (domain.length() > 50) {
                issues.add("Domain name is unusually long");
                confidence += 0.2;
            }

            // Check for excessive subdomains
            String[] parts = domain.split("\\.");
            if (parts.length > 4) {
                issues.add("Excessive number of subdomains");
                confidence += 0.25;
            }

            // Check for random-looking domain names
            if (isRandomDomain(domain)) {
                issues.add("Domain appears to be randomly generated");
                confidence += 0.3; // Reduced from 0.4
            }

            // Check for brand impersonation
            if (isBrandImpersonation(domain)) {
                issues.add("Potential brand impersonation detected");
                confidence += 0.5;
            }

            // Try to check if domain is accessible
            try {
                HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create("http://" + domain))
                    .timeout(Duration.ofSeconds(5))
                    .build();
                
                HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
                
                if (response.statusCode() >= 400) {
                    issues.add("Domain returns error status: " + response.statusCode());
                    confidence += 0.1;
                }
            } catch (Exception e) {
                issues.add("Domain is not accessible: " + e.getMessage());
                confidence += 0.2;
            }

            boolean isMalicious = confidence > 0.4; // Increased threshold from 0.3
            confidence = Math.min(confidence, 1.0);

            String details = issues.isEmpty() ? 
                "Domain appears legitimate" : 
                "Domain issues: " + String.join(", ", issues);

            return new UrlScanResult.DetectionResult(
                getMethodName(), isMalicious, details, confidence
            );

        } catch (Exception e) {
            return new UrlScanResult.DetectionResult(
                getMethodName(), false, "Error: " + e.getMessage(), 0.0
            );
        }
    }

    private String extractDomain(String url) {
        // First try to match with protocol
        Matcher matcher = DOMAIN_PATTERN.matcher(url);
        if (matcher.find()) {
            return matcher.group(1);
        }
        
        // If no protocol, try to extract domain directly
        // Remove www. prefix if present for normalization
        String normalizedUrl = url.replaceFirst("^www\\.", "");
        
        // Split by / and take the first part
        String[] parts = normalizedUrl.split("/", 2);
        String domainPart = parts[0];
        
        // Validate that it looks like a domain
        if (domainPart.contains(".") && domainPart.length() > 3) {
            return domainPart;
        }
        
        return null;
    }

    private boolean isSuspiciousTLD(String domain) {
        String[] suspiciousTLDs = {".tk", ".ml", ".ga", ".cf", ".gq", ".co", ".cc", ".xyz", ".top", ".club"};
        String lowerDomain = domain.toLowerCase();
        for (String tld : suspiciousTLDs) {
            if (lowerDomain.endsWith(tld)) {
                return true;
            }
        }
        return false;
    }

    private boolean isRandomDomain(String domain) {
        // Check for patterns that suggest random generation
        String domainPart = domain.split("\\.")[0];
        
        // Check for excessive numbers (more than 80% digits) - increased threshold
        long digitCount = domainPart.chars().filter(Character::isDigit).count();
        if (digitCount > domainPart.length() * 0.8) {
            return true;
        }

        // Check for repeated characters (4 or more consecutive same chars) - increased threshold
        for (int i = 0; i < domainPart.length() - 3; i++) {
            if (domainPart.charAt(i) == domainPart.charAt(i + 1) && 
                domainPart.charAt(i) == domainPart.charAt(i + 2) &&
                domainPart.charAt(i) == domainPart.charAt(i + 3)) {
                return true;
            }
        }
        
        // Check for very long random-looking strings (increased length threshold)
        if (domainPart.length() > 20 && domainPart.matches("[a-zA-Z0-9]{20,}")) {
            return true;
        }

        // Check for excessive randomness (entropy-based)
        if (domainPart.length() > 10) {
            double entropy = calculateEntropy(domainPart);
            if (entropy > 4.5 && domainPart.length() > 15) {
                return true;
            }
        }

        return false;
    }
    
    private double calculateEntropy(String str) {
        Map<Character, Integer> charCount = new HashMap<>();
        int totalChars = str.length();
        
        for (char c : str.toCharArray()) {
            charCount.put(c, charCount.getOrDefault(c, 0) + 1);
        }
        
        double entropy = 0.0;
        for (int count : charCount.values()) {
            double probability = (double) count / totalChars;
            if (probability > 0) {
                entropy -= probability * Math.log(probability) / Math.log(2);
            }
        }
        
        return entropy;
    }

    private boolean isBrandImpersonation(String domain) {
        String[] brands = {"google", "facebook", "amazon", "microsoft", "apple", "paypal", "ebay", "netflix", "twitter", "instagram"};
        String lowerDomain = domain.toLowerCase();
        
        for (String brand : brands) {
            if (lowerDomain.contains(brand) && !lowerDomain.equals(brand + ".com")) {
                return true;
            }
        }
        return false;
    }

    @Override
    public String getMethodName() {
        return "Domain Reputation Analysis";
    }

    @Override
    public double getConfidence() {
        return 0.6;
    }
} 