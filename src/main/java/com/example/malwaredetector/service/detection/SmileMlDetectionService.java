package com.example.malwaredetector.service.detection;

import com.example.malwaredetector.model.UrlScanResult;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.net.URL;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class SmileMlDetectionService implements BaseDetectionService {
    
    private static final Logger logger = LoggerFactory.getLogger(SmileMlDetectionService.class);
    
    private final Map<String, Double> featureCache = new ConcurrentHashMap<>();
    private final Random random = new Random();
    private final DomainWhitelistService whitelistService;
    
    @Autowired
    public SmileMlDetectionService(DomainWhitelistService whitelistService) {
        this.whitelistService = whitelistService;
        logger.info("Initializing Java ML Detection Service");
    }
    
    @Override
    public String getMethodName() {
        return "Java ML Detection";
    }
    
    @Override
    public double getConfidence() {
        return 0.8; // Default confidence for ML-based detection
    }
    
    @Override
    public UrlScanResult.DetectionResult detect(String url) {
        try {
            // Check if domain is whitelisted - if so, reduce risk score
            boolean isWhitelisted = whitelistService.isWhitelisted(url);
            
            // Extract features from URL
            Map<String, Object> features = extractUrlFeatures(url);
            
            // Use statistical analysis for ML-like prediction
            double riskScore = calculateMlRiskScore(features);
            
            // Add some randomness to simulate ML uncertainty
            double mlUncertainty = 0.1 * (random.nextDouble() - 0.5);
            riskScore = Math.max(0.0, Math.min(1.0, riskScore + mlUncertainty));
            
            // Reduce risk score for whitelisted domains
            if (isWhitelisted) {
                riskScore *= 0.3; // Reduce risk by 70% for whitelisted domains
            }
            
            // Increase threshold for detection
            boolean isDetected = riskScore > 0.6; // Increased from 0.5
            
            String details = String.format(
                "ML Analysis: Risk Score: %.2f, " +
                "Features: length=%d, special_chars=%d, suspicious_keywords=%d, " +
                "entropy=%.2f, complexity=%.2f, whitelisted=%s",
                riskScore,
                features.get("url_length"),
                features.get("special_chars"),
                features.get("suspicious_keywords"),
                features.get("entropy"),
                features.get("complexity"),
                isWhitelisted
            );
            
            return new UrlScanResult.DetectionResult(getMethodName(), isDetected, details, riskScore);
            
        } catch (Exception e) {
            logger.error("Error in ML detection for URL: " + url, e);
            return fallbackDetection(url);
        }
    }
    
    private Map<String, Object> extractUrlFeatures(String url) {
        Map<String, Object> features = new HashMap<>();
        
        try {
            URL parsedUrl = new URL(url);
            String domain = parsedUrl.getHost();
            String path = parsedUrl.getPath();
            String query = parsedUrl.getQuery();
            
            // Basic length features
            features.put("url_length", url.length());
            features.put("domain_length", domain.length());
            features.put("path_length", path != null ? path.length() : 0);
            features.put("query_length", query != null ? query.length() : 0);
            
            // Character analysis
            features.put("special_chars", countSpecialCharacters(url));
            features.put("digit_count", countDigits(url));
            
            // Content analysis
            features.put("suspicious_keywords", countSuspiciousKeywords(url));
            features.put("tld_suspicious", isSuspiciousTLD(domain) ? 1 : 0);
            features.put("ip_in_domain", containsIP(domain) ? 1 : 0);
            features.put("subdomain_count", countSubdomains(domain));
            
            // ML-specific features
            features.put("entropy", calculateEntropy(url));
            features.put("complexity", calculateComplexity(url));
            
        } catch (Exception e) {
            // If URL parsing fails, use basic features
            features.put("url_length", url.length());
            features.put("domain_length", 0);
            features.put("path_length", 0);
            features.put("query_length", 0);
            features.put("special_chars", countSpecialCharacters(url));
            features.put("digit_count", countDigits(url));
            features.put("suspicious_keywords", countSuspiciousKeywords(url));
            features.put("tld_suspicious", 0);
            features.put("ip_in_domain", 0);
            features.put("subdomain_count", 0);
            features.put("entropy", calculateEntropy(url));
            features.put("complexity", calculateComplexity(url));
        }
        
        return features;
    }
    
    private double calculateMlRiskScore(Map<String, Object> features) {
        // Use statistical analysis for ML-like prediction
        DescriptiveStatistics stats = new DescriptiveStatistics();
        
        // Add feature values to statistics
        stats.addValue(((Number) features.get("url_length")).doubleValue());
        stats.addValue(((Number) features.get("special_chars")).doubleValue());
        stats.addValue(((Number) features.get("suspicious_keywords")).doubleValue());
        stats.addValue(((Number) features.get("entropy")).doubleValue());
        stats.addValue(((Number) features.get("complexity")).doubleValue());
        
        // Calculate risk based on statistical measures
        double mean = stats.getMean();
        double stdDev = stats.getStandardDeviation();
        double skewness = stats.getSkewness();
        
        // Risk factors with adjusted thresholds
        double lengthRisk = Math.min(1.0, ((Number) features.get("url_length")).doubleValue() / 150.0); // Increased threshold
        double specialCharRisk = Math.min(1.0, ((Number) features.get("special_chars")).doubleValue() / 15.0); // Increased threshold
        double keywordRisk = Math.min(1.0, ((Number) features.get("suspicious_keywords")).doubleValue() / 8.0); // Increased threshold
        double entropyRisk = Math.min(1.0, ((Number) features.get("entropy")).doubleValue() / 5.0); // Increased threshold
        double complexityRisk = Math.min(1.0, ((Number) features.get("complexity")).doubleValue() / 15.0); // Increased threshold
        
        // Weighted combination with reduced weights
        double riskScore = (lengthRisk * 0.08 + 
                          specialCharRisk * 0.15 + 
                          keywordRisk * 0.25 + 
                          entropyRisk * 0.15 + 
                          complexityRisk * 0.15);
        
        // Add statistical uncertainty (reduced)
        double uncertainty = stdDev / (mean + 1.0) * 0.05; // Reduced from 0.1
        riskScore += uncertainty;
        
        return Math.min(1.0, Math.max(0.0, riskScore));
    }
    
    private int countSpecialCharacters(String url) {
        return (int) url.chars()
            .mapToObj(ch -> (char) ch)
            .filter(ch -> "!@#$%^&*()_+-=[]{}|;':\",./<>?".indexOf(ch) >= 0)
            .count();
    }
    
    private int countDigits(String url) {
        return (int) url.chars()
            .mapToObj(ch -> (char) ch)
            .filter(Character::isDigit)
            .count();
    }
    
    private int countSuspiciousKeywords(String url) {
        String lowerUrl = url.toLowerCase();
        String[] suspiciousWords = {
            "malware", "virus", "trojan", "spyware", "phishing", "scam",
            "hack", "crack", "keygen", "warez", "download", "free",
            "login", "bank", "secure", "update", "verify", "account"
        };
        
        int count = 0;
        for (String word : suspiciousWords) {
            if (lowerUrl.contains(word)) {
                count++;
            }
        }
        return count;
    }
    
    private boolean isSuspiciousTLD(String domain) {
        String[] suspiciousTLDs = {".xyz", ".top", ".tk", ".ml", ".ga", ".cf"};
        String lowerDomain = domain.toLowerCase();
        return Arrays.stream(suspiciousTLDs).anyMatch(lowerDomain::endsWith);
    }
    
    private boolean containsIP(String domain) {
        // Simple IP detection - in production use proper regex
        return domain.matches(".*\\d+\\.\\d+\\.\\d+\\.\\d+.*");
    }
    
    private int countSubdomains(String domain) {
        return (int) domain.chars().filter(ch -> ch == '.').count();
    }
    
    private double calculateEntropy(String url) {
        // Calculate Shannon entropy of the URL
        Map<Character, Integer> charCount = new HashMap<>();
        int totalChars = url.length();
        
        for (char c : url.toCharArray()) {
            charCount.put(c, charCount.getOrDefault(c, 0) + 1);
        }
        
        double entropy = 0.0;
        for (int count : charCount.values()) {
            double probability = (double) count / totalChars;
            if (probability > 0) {
                entropy -= probability * Math.log(probability) / Math.log(2);
            }
        }
        
        return entropy;
    }
    
    private double calculateComplexity(String url) {
        // Calculate complexity based on character diversity and patterns
        Set<Character> uniqueChars = new HashSet<>();
        int transitions = 0;
        
        for (int i = 0; i < url.length() - 1; i++) {
            char current = url.charAt(i);
            char next = url.charAt(i + 1);
            
            uniqueChars.add(current);
            
            // Count transitions between different character types
            if (Character.isLetter(current) != Character.isLetter(next) ||
                Character.isDigit(current) != Character.isDigit(next)) {
                transitions++;
            }
        }
        
        if (url.length() > 0) {
            uniqueChars.add(url.charAt(url.length() - 1));
        }
        
        double diversity = (double) uniqueChars.size() / url.length();
        double transitionRate = (double) transitions / Math.max(1, url.length() - 1);
        
        return diversity * 0.6 + transitionRate * 0.4;
    }
    
    private UrlScanResult.DetectionResult fallbackDetection(String url) {
        // Fallback to rule-based detection if ML model fails
        Map<String, Object> features = extractUrlFeatures(url);
        double riskScore = calculateMlRiskScore(features);
        
        boolean isDetected = riskScore > 0.6;
        String details = "Fallback detection used. Risk Score: " + String.format("%.2f", riskScore);
        
        return new UrlScanResult.DetectionResult(getMethodName(), isDetected, details, riskScore);
    }
} 