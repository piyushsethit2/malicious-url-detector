package com.example.malwaredetector.service;

import com.example.malwaredetector.model.UrlScanRequest;
import com.example.malwaredetector.model.UrlScanResult;
import com.example.malwaredetector.repository.UrlScanRequestRepository;
import com.example.malwaredetector.service.detection.BaseDetectionService;
import com.example.malwaredetector.service.detection.DomainWhitelistService;
import com.example.malwaredetector.service.detection.TransformerMLDetectionService;
import com.example.malwaredetector.service.detection.DynamicContentAnalyzerService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

@Service
public class ComprehensiveMalwareDetectionService {

    private final List<BaseDetectionService> detectionServices;
    private final UrlScanRequestRepository repository;
    private final DomainWhitelistService whitelistService;
    private final TransformerMLDetectionService mlService;
    private final DynamicContentAnalyzerService contentAnalyzer;
    private final ExecutorService executorService;

    @Autowired
    public ComprehensiveMalwareDetectionService(
            List<BaseDetectionService> detectionServices,
            UrlScanRequestRepository repository,
            DomainWhitelistService whitelistService,
            TransformerMLDetectionService mlService,
            DynamicContentAnalyzerService contentAnalyzer) {
        this.detectionServices = detectionServices;
        this.repository = repository;
        this.whitelistService = whitelistService;
        this.mlService = mlService;
        this.contentAnalyzer = contentAnalyzer;
        this.executorService = Executors.newFixedThreadPool(10);
    }

    public UrlScanResult scanUrl(String url) {
        // Normalize URL for consistent processing
        String normalizedUrl = normalizeUrl(url);
        
        UrlScanResult result = new UrlScanResult();
        result.setUrl(normalizedUrl);
        result.setScannedAt(LocalDateTime.now());

        // Check if domain is whitelisted first
        boolean isWhitelisted = whitelistService.isWhitelisted(normalizedUrl);
        
        // Run all detection services in parallel
        List<CompletableFuture<UrlScanResult.DetectionResult>> futures = new ArrayList<>();
        
        // Add standard detection services
        for (BaseDetectionService service : detectionServices) {
            CompletableFuture<UrlScanResult.DetectionResult> future = CompletableFuture.supplyAsync(() -> {
                try {
                    return service.detect(normalizedUrl);
                } catch (Exception e) {
                    return new UrlScanResult.DetectionResult(
                        service.getMethodName(), false, "Error: " + e.getMessage(), 0.0
                    );
                }
            }, executorService);
            futures.add(future);
        }

        // Add advanced ML detection with content analysis
        CompletableFuture<UrlScanResult.DetectionResult> mlFuture = CompletableFuture.supplyAsync(() -> {
            try {
                // First get content from the URL
                UrlScanResult.DetectionResult contentResult = contentAnalyzer.detect(normalizedUrl);
                String content = contentResult.getDetails(); // This contains the fetched content
                
                // Use ML service with both URL and content
                UrlScanResult.DetectionResult mlResult = mlService.detect(normalizedUrl, content);
                return mlResult;
            } catch (Exception e) {
                return new UrlScanResult.DetectionResult(
                    "TransformerML", false, "Error: " + e.getMessage(), 0.0
                );
            }
        }, executorService);
        futures.add(mlFuture);

        // Wait for all results
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();

        // Collect results
        Map<String, UrlScanResult.DetectionResult> detectionResults = new HashMap<>();
        List<String> threats = new ArrayList<>();
        double totalConfidence = 0.0;
        int maliciousCount = 0;

        for (CompletableFuture<UrlScanResult.DetectionResult> future : futures) {
            try {
                UrlScanResult.DetectionResult detectionResult = future.get();
                detectionResults.put(detectionResult.getMethod(), detectionResult);
                
                if (detectionResult.isDetected()) {
                    maliciousCount++;
                    threats.add(detectionResult.getDetails());
                }
                
                totalConfidence += detectionResult.getConfidence();
            } catch (Exception e) {
                // Handle any remaining exceptions
            }
        }

        // Calculate overall result with improved logic
        int totalServices = detectionServices.size() + 1; // +1 for ML service
        int successfulServices = 0;
        double successfulConfidence = 0.0;
        
        // Only count services that actually returned results (not errors)
        for (UrlScanResult.DetectionResult detectionResult : detectionResults.values()) {
            if (!detectionResult.getDetails().startsWith("Error:") && !detectionResult.getDetails().startsWith("API key not configured")) {
                successfulServices++;
                successfulConfidence += detectionResult.getConfidence();
            }
        }
        
        // Calculate average confidence only from successful services
        double averageConfidence = successfulServices > 0 ? successfulConfidence / successfulServices : 0.0;
        
        // Adjust thresholds based on whitelist status
        int maliciousThreshold = isWhitelisted ? 2 : 1; // Require more detections for whitelisted domains
        double confidenceThreshold = isWhitelisted ? 0.6 : 0.5; // Higher confidence threshold for whitelisted domains
        
        // CRITICAL FIX: Prioritize malicious detections over confidence averaging
        // If ANY service detects malicious with reasonable confidence, mark as malicious
        boolean isMalicious = maliciousCount >= maliciousThreshold || 
                             hasHighConfidenceDetection(detectionResults) ||
                             (maliciousCount > 0 && averageConfidence > 0.3); // Lower threshold if any malicious detection
        
        result.setDetectionResults(detectionResults);
        result.setThreats(threats);
        result.setMalicious(isMalicious);
        result.setConfidenceScore(averageConfidence);
        result.setOverallStatus(isMalicious ? "MALICIOUS" : "CLEAN");
        
        // Generate recommendation
        result.setRecommendation(generateRecommendation(isMalicious, maliciousCount, averageConfidence, threats));

        // Save to database
        saveToDatabase(result);

        return result;
    }

    private void saveToDatabase(UrlScanResult result) {
        UrlScanRequest request = new UrlScanRequest();
        request.setUrl(result.getUrl());
        request.setStatus(result.getOverallStatus());
        request.setSource("Comprehensive Analysis");
        request.setScannedAt(result.getScannedAt());
        request.setDetails("Confidence: " + String.format("%.2f", result.getConfidenceScore()) + 
                         ", Threats: " + String.join(", ", result.getThreats()));
        repository.save(request);
    }

    private String generateRecommendation(boolean isMalicious, int maliciousCount, double confidence, List<String> threats) {
        if (isMalicious) {
            if (maliciousCount >= 3) {
                return "HIGH RISK: Multiple detection methods flagged this URL as malicious. Avoid visiting this site.";
            } else if (confidence > 0.7) {
                return "MEDIUM-HIGH RISK: Strong indicators of malicious content detected. Exercise extreme caution.";
            } else {
                return "MEDIUM RISK: Some suspicious indicators detected. Proceed with caution.";
            }
        } else {
            if (confidence < 0.2) {
                return "LOW RISK: URL appears safe based on comprehensive analysis.";
            } else {
                return "LOW-MEDIUM RISK: Some minor concerns detected, but overall appears safe.";
            }
        }
    }
    
    private boolean hasHighConfidenceDetection(Map<String, UrlScanResult.DetectionResult> detectionResults) {
        // Check if any service has reasonable confidence (>0.4) and detected as malicious
        for (UrlScanResult.DetectionResult result : detectionResults.values()) {
            if (result.isDetected() && result.getConfidence() > 0.4) {
                return true;
            }
        }
        return false;
    }

    public List<UrlScanRequest> getHistory(String url) {
        return repository.findByUrl(url);
    }

    public void shutdown() {
        executorService.shutdown();
    }
    
    /**
     * Normalize URL for consistent processing
     * - Remove www. prefix for consistency
     * - Ensure proper scheme if missing
     * - Handle edge cases
     */
    private String normalizeUrl(String url) {
        if (url == null || url.trim().isEmpty()) {
            return url;
        }
        
        String normalized = url.trim();
        
        // Remove www. prefix for consistency
        if (normalized.startsWith("www.")) {
            normalized = normalized.substring(4);
        }
        
        // If no scheme is present, add https://
        if (!normalized.startsWith("http://") && !normalized.startsWith("https://")) {
            normalized = "https://" + normalized;
        }
        
        return normalized;
    }
} 